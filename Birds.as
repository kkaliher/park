class Birds{		var parentMC:MovieClip;	var classObj:Object;	var birds:Number;	var bird:MovieClip;	var birdArt:MovieClip;	function Birds(pMC){		parentMC = pMC;		classObj = this;		birds = 0;	}		public function makeBird():Void{		birds++		bird = parentMC.createEmptyMovieClip("bird"+birds,2000+birds);		birdArt = bird.attachMovie("bird","birdArt",0);		trace ("made bird ");		bird.classObj = classObj;		with (bird){			_xscale=7;			_yscale=7;		}		bird.pace = 2;		if (parentMC.groundGrown==false or Math.random()<.5){			bird._x = -5;			bird.flip=1;		} else {			bird._x = parentMC.w+5;			bird.flip=-1;		}		birdArt._xscale*=bird.flip;		birdArt._alpha=60;		bird._y = Math.round(parentMC.h/5+random(parentMC.h/3));		//trace (bird +" start = "+bird._x+", "+bird._y);		bird.angle = Math.random()*Math.PI/3;		if (bird.flip==-1){			bird.angle = Math.PI-bird.angle;		}		//trace (bird +" angle = "+bird.angle);		bird.state = "fly";		birdArt.gotoAndPlay("fly");		bird.onEnterFrame = function(){			this.classObj.birdBehavior(this);		}	}		public function birdBehavior(b:MovieClip):Void{		if (b.grounded!=true and parentMC.G.getGroundY(Math.round(b._x))<b._y+b.pace*Math.sin(b.angle)){			b._y = parentMC.G.getGroundY(Math.round(b._x));			b.state = "still";			b.tick = 0;			b.tickStop = 120+random(480);			b.birdArt.gotoAndStop("still");			b.grounded=true;			break;		}		switch (b.state){			case "fly":				if (b._x<-6 or b._x>parentMC.w+6 or b._y<-6){					destroy(b);					break;				}								b._x+=b.pace*Math.cos(b.angle);				b._y+=b.pace*Math.sin(b.angle);				if (b.angle>5*Math.PI/4 and b.angle<=3*Math.PI/2){					b.angle-=1;				}				if (b.angle>3*Math.PI/2 and b.angle<7*Math.PI/4){					b.angle+=1;				}				if (b.angle>2*Math.PI){					b.angle-=2*Math.PI;				}				if (b.angle<0){					b.angle+=2*Math.PI;				}				if (b.hitTest(parentMC.jogger) or b.hitTest(parentMC.dog)){					b.angle-=1*b.flip;				}				if (random(10)==1){					b.angle+=(-3+random(7))/10;					if (Math.cos(b.angle)*b.flip<-0.1){						b.flip*=-1;						b.birdArt._xscale*=-1;					}				}				if (parentMC.raining==true or b._y>parentMC.h/3 and random(100)==1){					b.state="tree";					b.tree = parentMC["tree"+(random(parentMC.G.getTrees())+1)];					//trace (b+" to land in "+b.tree);					if (parentMC.raining!=true){						b.treeY = b.tree._y-b.tree._height;					} else {						b.treeY = b.tree._y-b.tree.stem._height;					}				}				break;			case "still":				if (parentMC.raining and b.grounded!=true){					return;				}				b.tick++;				if (b.tick==b.tickStop or (b.grounded==true and (Math.abs(b._x-parentMC.jogger._x)<10 or 																 Math.abs(b._x-parentMC.dog._x)<10))){					b.angle = 2*Math.PI-Math.random()*Math.PI;					//trace ("bird angle = "+b.angle);					b.grounded=false;					b.state="fly";					b.birdArt.gotoAndPlay("fly");				}				break;			case "tree":				if (b.tree.circle.hitTest(b) and Math.abs(b._x-b.tree._x)<b.tree.circle._width/3){					//trace ("hit tree");					b.state = "still";					b.tick = 0;					b.tickStop = 120+random(480);					b.birdArt.gotoAndStop("still");					break;				}  				b._x+=b.pace*Math.cos(b.angle);				b._y+=b.pace*Math.sin(b.angle);				var a = Math.atan((b.treeY-b._y)/(b.tree._x-b._x));				if ((a<0 and b.tree._x<b._x) or (b.treeY<b._y and b.tree._x<b._x)){					a+=Math.PI;				}				if (b.angle<a){					b.angle+=0.1;				} else {					b.angle-=0.1;				}				//trace ("angle = "+b.angle);				if (Math.cos(b.angle)*b.flip<-0.1){					b.flip*=-1;					b.birdArt._xscale*=-1;				}		}	}		public function destroy(b:MovieClip):Void{		trace ("destroyed "+b);		delete b.onEnterFrame;		b.removeMovieClip();	}}