class Ground{	public var startX:Number;private var linedepth:Number;private var pace:Number;private var beat:Number;private var baseY:Number;private var startY:Number;private var endX:Number;private var endY:Number;private var controlX:Number;private var controlY:Number;private var prevCY:Number;private var prevCX:Number;private var startSlope:Number;private var slopeAdj:Number;private var slopeMultiplier:Number;private var nextSlope:Number;private var treeNumber:Number;private var curviness:Number = .4private var tick:Number = 0;private var parentMC:MovieClip;private var ground:MovieClip;private var groundGrower:MovieClip;private var classObj:Object;private var t:MakeTree;private var growInterval:Number;function Ground(pMC:MovieClip){	trace ("new Ground");	linedepth = 1;	startX = 0;	pace = 2;	beat = 60;	baseY = 2*pMC.h/3;	trace ("basey = "+baseY);	startY = baseY;	prevCY = startY;	prevCX = 0;	startSlope = 0;	slopeAdj = 0;	slopeMultiplier = .5;	nextSlope = 0;	getNextSlope();		treeNumber = 0;		parentMC = pMC;	ground = parentMC.createEmptyMovieClip("ground",0);	ground.pace = pace;	classObj = this;	groundGrower = ground.createEmptyMovieClip("groundGrower",10000);	groundGrower.classObj = classObj;	groundGrower.onEnterFrame = function(){		this.classObj.growGround();	}}	private function getNextSlope():Void{	slopeMultiplier*=-1;	nextSlope = slopeMultiplier*Math.random();	//trace ("nextSlope = "+nextSlope);	slopeAdj = (nextSlope-startSlope)/(beat)	//trace ("slopeAdj = "+slopeAdj);}private function drawLine(startX:Number,				   startY:Number,				  endX:Number,				  endY:Number,				  controlX:Number,				  controlY:Number,				  color:Number,				  lineweight:Number):Void{	var line:MovieClip = ground.createEmptyMovieClip("line"+startX,-1000+startX);	//trace ("line = "+line);	with (line){		lineStyle(lineweight,color,100);		moveTo(startX,startY);		lineTo(endX,endY);	}	line.Y=startY;}public function growGround():Void{		//trace ("growGround");		tick++;		startSlope+=slopeAdj;		endX=startX+pace;		endY=startY+(startSlope*pace);		controlX = startX+curviness*(startX-prevCX);		controlY = startY+curviness*(startY-prevCY);		drawLine(startX,				  startY,				  endX,				  endY,				  controlX,				  controlY,				  0x636363,				  .5);		if (tick*pace==beat){			tick=0;			getNextSlope();		}		if (random(100)<5*pace){			generateTree(startX,startY);		}		startX=endX;		startY=endY;		prevCX=controlX;		prevCY=controlY;		if (startX>parentMC.w){			stopGrowing();		}}private function generateTree(sX:Number,					  sY:Number):Void{	treeNumber++;	new MakeTree(0,			 5+random(15),			 1,			 0,			 2+random(10),			 .5,			 sX,			 sY,			 treeNumber,			 parentMC);}public function getX():Number{	return (startX);}public function getGroundY(X:Number):Number{		for (var i=-pace/2;i<=pace/2;i++){			if (ground["line"+(X+i)].Y!=undefined){				var groundY = parentMC.ground["line"+(X+i)].Y;			}		}		return (groundY);}public function hasTree(X:Number):Boolean{	if (ground["line"+X].tree!=undefined){		return true;	} else {		return false;	}}public function getTrees():Number{	return (treeNumber);}public function stopGrowing(){	trace ("stopGrowing ground");	delete groundGrower.onEnterFrame;	groundGrower.removeMovieClip();	parentMC.classObj.doEnd();}public function destroy(){	delete groundGrower.onEnterFrame;	delete ground;	delete classObj;}	//end of class}