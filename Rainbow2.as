class Rainbow {		private var classObj:Object;	private var parentMC:MovieClip;	private var rainbow:MovieClip;	private var centerX:Number;	private var centerY:Number;	private var radius:Number;	private var size:Number;	private var colorArray:Array;		private var arcNum:Number;		private var angle:Number;	private var angleInc:Number;	private var radians:Number;	private var segment:Number;	private var stopSegment:Number;	private var stopCount:Number;		function Rainbow(pMC:MovieClip){		if (pMC.raining==true){			return;		}		trace ("new Rainbow");		parentMC = pMC;		classObj = this;		centerX = pMC.w/2;		centerY = pMC.h;		radius = (5*pMC.w/Stage.height)+pMC.w/2;		size = 3*pMC.w/Stage.height;		colorArray = new Array(0xFF0033,0xFF9933,0xFFFF00,0x66FF00,0x0066FF,0x9900FF,0xFF00FF);		arcNum=0;		rainbow = pMC.createEmptyMovieClip("rainbow",7000);		rainbow._alpha=100;		makeArcs();	}		private function makeArcs():Void{		for (var i=0;i<colorArray.length;i++){			var color = colorArray[i];			if (colorArray[i]==0){				continue;			}			var cradius = radius-(i*size/2);			drawArc(	centerX,						centerY,						cradius,						i,						color,						size+1);		}	}		private function stopGrowing():Void{		trace ("stop growing");		stopSegment = segment;		segment=0;		rainbow.onEnterFrame = function(){			//this.classObj.fadeArc();		}	}		private function fadeArc():Void{		segment++;		for (var i=0;i<colorArray.length;i++){			rainbow["line"+(i*1000+segment)].clear();			rainbow["line"+(i*1000+segment)].removeMovieClip();		}		if (segment==stopSegment){			delete rainbow.onEnterFrame;		}	}		private function getRadians(a):Number{		return ( a*Math.PI/180 );	}		private function drawLine(startX:Number,				  			startY:Number,				  			endX:Number,				  			endY:Number,				  			segment:Number,				  			color:Number,				  			lineweight:Number,							slice:Number):Void{		if (parentMC.G.getGroundY(Math.floor(endX))!=undefined and endY+3>=parentMC.G.getGroundY(Math.floor(endX))){			if (angle <90){				stopCount++;				colorArray[slice]=0;				if (stopCount==7){					stopGrowing();				}			}			return;		}		var line:MovieClip = rainbow.createEmptyMovieClip("line"+segment,segment);		//trace ("rainbow segment from "+startX+","+startY+" to "+endX+","+endY);		with (line){			lineStyle(lineweight,color,20);			moveTo(startX,startY);			lineTo(endX,endY);		}	}		function drawArc(sX,					sY,					r,					segment,					color,					lineweight):Void{	var r2 = 2*r;	var arc = rainbow.createEmptyMovieClip("arc"+segment,segment);	with (arc){		lineStyle(lineweight,color,30);		moveTo(sX-r,sY);		curveTo(sX,sY-r2,sX+r,sY);	}}function drawCircle(target_mc:MovieClip, radius:Number, fillColor:Number, fillAlpha:Number):Void {    var x:Number = radius;    var y:Number = radius;    with (target_mc) {        beginFill(fillColor, fillAlpha);         moveTo(x + radius, y);        curveTo(radius + x, Math.tan(Math.PI / 8) * radius + y, Math.sin(Math.PI / 4) * radius + x, Math.sin(Math.PI / 4) * radius + y);        curveTo(Math.tan(Math.PI / 8) * radius + x, radius + y, x, radius + y);        curveTo(-Math.tan(Math.PI / 8) * radius + x, radius+ y, -Math.sin(Math.PI / 4) * radius + x, Math.sin(Math.PI / 4) * radius + y);        curveTo(-radius + x, Math.tan(Math.PI / 8) * radius + y, -radius + x, y);        curveTo(-radius + x, -Math.tan(Math.PI / 8) * radius + y, -Math.sin(Math.PI / 4) * radius + x, -Math.sin(Math.PI / 4) * radius + y);        curveTo(-Math.tan(Math.PI / 8) * radius + x, -radius + y, x, -radius + y);        curveTo(Math.tan(Math.PI / 8) * radius + x, -radius + y, Math.sin(Math.PI / 4) * radius + x, -Math.sin(Math.PI / 4) * radius + y);        curveTo(radius + x, -Math.tan(Math.PI / 8) * radius + y, radius + x, y);        endFill();    }}}